#!/usr/bin/env zsh
# set -x
BATCHSIZE=500
# ---------------------------------------------
# Pac‑Man‑Style Progress Bar
# ---------------------------------------------
# set -u
# unset x

has_colors() {
  if (( $+HAS_COLORS )); then
    :
  else
    case $TERM in
      *-256color) typeset -g HAS_COLORS=1 ;;
      vt100|dumb) typeset -g HAS_COLORS=0 ;;
      *)
        local colors
        case $OSTYPE in
          freebsd*|dragonfly*) colors=$(tput Co) ;;
          *) colors=$(tput colors) ;;
        esac
        typeset -g HAS_COLORS=$(( colors >= 8 ))
        ;;
    esac
  fi
  (( HAS_COLORS ))
}
has_colors "$@"

help() {
  local GREEN=$'\e[0;32;40m'
  local BLUE=$'\e[0;34;40m'
  local NC=$'\e[0m'   # reset color

  echo
  echo -en " Usage: [zsh] progressbar-zsh ${GREEN}-b ${BLUE}[positive integer]${NC}  - How many files should be processed at a time."
  echo -en " You can mark the file as executable (chmod +x progressbar-zsh) to run the script without the zsh prefix.\n"
  echo
  exit 1
}

############################################################
# Redraw prompt when terminal size changes
############################################################
TRAPWINCH() {
  zle && zle -R
}
TRAPWINCH "$@"

progress-bar() {
  local current=$1
  local len=$2
  local COLUMNS=$(tput cols)
  local LINES=$(tput lines)

  local GREEN=$'\e[0;32;40m'
  local BROWN=$'\e[0;33;40m'
  local YELLOW=$'\e[1;33;40m'
  local RED=$'\e[0;31;40m'
  local NC=$'\e[0m'                # reset color

  local pm_char1="${YELLOW}C${NC}"    # this is one of two characters for the animation
  local pm_char2="${YELLOW}c${NC}"    # this is the second character for the animation
  local bar_char1="${BROWN}.${NC}"    # this character apears behind Pac-Man
  local bar_char2="${GREEN}o${NC}"    # this character is eaten by Pac-Man
#  local bar_char2="${GREEN}$·${NC}"    # you can also try middle-dot
#  local bar_char2="${GREEN}$( printf $'\u00B7' )${NC}"    # with UTF-8 code -> ·

  local perc_done=$((current * 100 / len))

  local suffix
        suffix=$(printf ' %d / %d (%d%%)' "$current" "$len" "$perc_done")
  local length=$(( COLUMNS - 2 - ${#suffix} ))
     (( length < 0 )) && length=0

  local num_bars=$((perc_done * length / 100))

  local pos=$((num_bars - 1))
    (( pos < 0 )) && pos=0

  local perc_color
    if (( perc_done < 31 )); then
          perc_color=${RED}
    elif (( perc_done < 61 )); then
          perc_color=${YELLOW}
    else
          perc_color=${GREEN}
    fi
# progress bar
    bar='['
    local i
    for ((i = 0; i < length; i++)); do
      if (( i < pos )); then
          bar+=$bar_char1 # behind Pac-Man
      elif (( i == pos && perc_done < 100 )); then
      # Pac-Man
          (( i % 2 == 0 )) && bar+=$pm_char1 || bar+=$pm_char2
      else
          bar+=$bar_char2 # in front of Pac-Man
      fi
    done
    bar+=']'
    printf '\e[s' # save the cursor position
      printf '\e[%d;1H' "$LINES"  #  -> bottom row, first column  (1-based!)
        printf '%s %s/%s %s%s%%%s' "$bar" "$current" "$len" "$perc_color" "$perc_done" "$NC"
      printf '\e[K' #  clear the line
    printf '\e[u' #  restores the cursor to the last saved position
}

batchsize () {
   local GREEN=$'\e[0;32;40m'
   local RED=$'\e[0;31;40m'
   local NC=$'\e[0m'

   printf '\n%s\n' 'Found '$len' files.'

   if
    [[ $BATCHSIZE -lt 1 ]] ; then
        BATCHSIZE=1 && printf '\r%s\n' "Processing "${GREEN}$"one (1)"${NC}" file at a time"
    elif
    [[ $BATCHSIZE == 1 ]] ; then
       printf '\r%s\n' "Processing "${GREEN}"one (1)"${NC}" file at a time"
    else
       printf '\r%s\n' "Processing batch of "${GREEN}${BATCHSIZE}${NC}" files"
   fi
}

process-files() {
   local files=("$@")
   local file
   for file in "${files[@]}"; do
#   you can add your code here, i.e., 'cp $file /dev/null'
     printf '\r%s\n' "-> $file"
   done
#	sleep .1
}

# initialise terminal
init-term() {
    local COLUMNS=$(tput cols)
    local LINES=$(tput lines)

    printf '\n' # ensure we have space for the progress bar
      printf '\e[s' # save the cursor location
        printf '\e[%d;%dr' 1 "$((LINES -1))" # set the scrollable region (margin)
      printf '\e[u' #  restore the cursor location
    printf '\e[1A' # move cursor up
    tput civis # make cursor invisible
}

deinit-term() {
    local COLUMNS=$(tput cols)
    local LINES=$(tput lines)

    printf '\e[s' # save the cursor location
      printf '\e[%d;%dr' 1 "$LINES" # reset the scrollable region (margin)
        printf '\e[%d;%dH' "$LINES" 1 # move cursor to bottom line
      printf '\e[0K' #  clear the line
    printf '\e[u' #  reset the cursor location
    tput cnorm # make cursor visible
}

finish () {
 local GREEN=$'\e[0;32;40m'
 local NC=$'\e[0m'                # reset color

 printf '%s\n' ${GREEN}"Done!"${NC}
 }

main() {

      local OPTARG OPTIND opt
      while getopts 'b:' opt; do
            case "$opt" in
                    b) BATCHSIZE=$OPTARG;;
                    *) help;;
            esac
      done
#
# Infomation about the setopt parameters:
#       LOCAL_OPTIONS UNSET # declare setopt parameters locally and restore it after function call
#       DOT_GLOB # Do not require a leading ‘.’ in a filename to be matched explicitly.
#       GLOB_STAR_SHORT # When this option is set and the default zsh-style globbing is in effect, the pattern ‘**/*’ can be abbreviated to ‘**’ and the pattern ‘***/*’ can be abbreviated to ***. Hence ‘**.c’ finds a file ending in .c in any subdirectory, and ‘***.c’ does the same while also following symbolic links. A / immediately after the ‘**’ or ‘***’ forces the pattern to be treated as the unabbreviated form.
#       extendedglob
#       EXTENDED_GLOB # Treat the ‘#’, ‘~’ and ‘^’ characters as part of patterns for filename generation, etc. (An initial unquoted ‘~’ always produces named directory expansion.)
#
# We write this in two lines
#
      setopt LOCAL_OPTIONS UNSET
      setopt DOT_GLOB GLOB_STAR_SHORT EXTENDED_GLOB extendedglob NULLGLOB

      local COLUMNS=$(tput cols) # determine the number of columns of the terminal window
      local LINES=$(tput lines)  # determine the number of lines of the terminal window

      trap deinit-term EXIT
      trap init-term
      init-term

      local GREEN=$'\e[0;32;40m'
      local RED=$'\e[0;31;40m'
      local NC=$'\e[0m'                # reset color

      if
        [[ $BATCHSIZE -lt 1 ]] ; then
        printf '\n%s%s%s\n%s\n' "BATCHSIZE of "${RED} ${BATCHSIZE} ${NC}" is not valid." "BATCHSIZE will be set to "${GREEN}"1"${NC}"."
      fi
      printf '\n%s%s%s' "Searching files in "${GREEN} $(pwd) ${NC}" and its subdirectories…"
      files=(./**/*)                 # Array with all files in the working directory and its subdirectories. You may want to adjust this to your needs,e.g., './**/*.tmp'
      len=${#files[@]}

      local i
      for ((i=0; i < len; i += BATCHSIZE)); do
        batchsize
        progress-bar "$((i+1))" "$len"
        process-files "${files[@]:$((i)):$BATCHSIZE}"
      done

      # Completing the progress bar regardless of the size of the BATCHSIZE variable
      progress-bar "$len" "$len"
}

main "$@"
finish "$@"
